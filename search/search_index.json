{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"DCC-EX Documentation","text":"<p>Testing MkDocs for DCC-EX documentation</p>"},{"location":"experimenting/codeblocks/","title":"Experimenting with code block colours","text":"<p>Adding a full code block of C++ to test colours and syntax high lighting.</p> <pre><code>#include &lt;iostream&gt;  // Standard I/O library\n#include &lt;vector&gt;    // For dynamic arrays\n#include &lt;string&gt;    // For string manipulation\n#include &lt;map&gt;       // For key-value pairs\n\n// A simple namespace to organize code\nnamespace MyLibrary {\n\nconst double PI_VALUE = 3.1415926535; // A global constant\n\n/**\n * @brief Represents a generic item with properties.\n * This is a multi-line comment to test comment colors.\n */\nclass GenericItem {\nprivate:\n    std::string itemName;\n    int itemId;\n    double itemPrice;\n    bool isAvailable;\n\npublic:\n    // Constructor with default values\n    GenericItem(const std::string&amp; name = \"Default Item\", int id = 0, double price = 0.0, bool available = true)\n        : itemName(name), itemId(id), itemPrice(price), isAvailable(available) {}\n\n    // Member function to display item details\n    void displayDetails() const {\n        std::cout &lt;&lt; \"Item Name: \" &lt;&lt; itemName &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"Item ID: \" &lt;&lt; itemId &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"Price: $\" &lt;&lt; itemPrice &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"Available: \" &lt;&lt; (isAvailable ? \"Yes\" : \"No\") &lt;&lt; std::endl;\n    }\n\n    // Getter for itemPrice\n    double getPrice() const {\n        return itemPrice;\n    }\n\n    // Setter for itemPrice (with a simple check)\n    void setPrice(double newPrice) {\n        if (newPrice &gt;= 0.0) {\n            this-&gt;itemPrice = newPrice;\n        } else {\n            std::cerr &lt;&lt; \"Warning: Price cannot be negative.\" &lt;&lt; std::endl;\n        }\n    }\n}; // Don't forget the semicolon after class definition!\n\n// Template function to find the maximum of two values\ntemplate &lt;typename T&gt;\nT findMax(T a, T b) {\n    return (a &gt; b) ? a : b; // Ternary operator test\n}\n\n} // end namespace MyLibrary\n\n// Main function - entry point of the program\nint main() {\n    using namespace MyLibrary; // Use MyLibrary namespace\n\n    // Create instances of GenericItem\n    GenericItem item1(\"Laptop\", 101, 1200.50, true);\n    GenericItem* item2 = new GenericItem(\"Mouse\", 202, 25.99, false); // Using 'new'\n\n    // Display details using a loop\n    std::vector&lt;GenericItem&gt; inventory;\n    inventory.push_back(item1);\n    inventory.push_back(*item2);\n\n    std::cout &lt;&lt; \"--- Inventory Details ---\" &lt;&lt; std::endl;\n    for (const auto&amp; item : inventory) { // Range-based for loop\n        item.displayDetails();\n        std::cout &lt;&lt; \"-------------------------\" &lt;&lt; std::endl;\n    }\n\n    // Test the template function\n    int maxInt = findMax(10, 20);\n    double maxDouble = findMax(PI_VALUE, item2-&gt;getPrice()); // Accessing member via pointer\n\n    std::cout &lt;&lt; \"Maximum integer: \" &lt;&lt; maxInt &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Maximum double: \" &lt;&lt; maxDouble &lt;&lt; std::endl;\n\n    // Exception handling test\n    try {\n        if (item1.getPrice() &lt; 1.0) {\n            throw \"Price too low!\"; // Throwing a string literal\n        }\n        item1.setPrice(1500.00); // Change price\n    } catch (const char* msg) { // Catching a C-style string\n        std::cerr &lt;&lt; \"Error: \" &lt;&lt; msg &lt;&lt; std::endl;\n    }\n\n    // Clean up dynamic memory\n    delete item2; // Using 'delete'\n    item2 = nullptr; // Best practice to nullify pointer after delete\n\n    // Return 0 for successful execution (integer literal)\n    return 0;\n}\n</code></pre>"},{"location":"experimenting/flowchart/","title":"mermaid flowchart","text":"<pre><code>graph LR\n  A[Start] --&gt; B{Error?};\n  B --&gt;|Yes| C[Hmm...];\n  C --&gt; D[Debug];\n  D --&gt; B;\n  B ----&gt;|No| E[Yay!];</code></pre>"},{"location":"experimenting/sequence/","title":"mermaid sequence diagram","text":"<pre><code>sequenceDiagram\n  autonumber\n  Alice-&gt;&gt;John: Hello John, how are you?\n  loop Healthcheck\n      John-&gt;&gt;John: Fight against hypochondria\n  end\n  Note right of John: Rational thoughts!\n  John--&gt;&gt;Alice: Great!\n  John-&gt;&gt;Bob: How about you?\n  Bob--&gt;&gt;John: Jolly good!</code></pre>"},{"location":"experimenting/statediagram/","title":"mermaid state diagram","text":"<pre><code>stateDiagram-v2\n  state fork_state &lt;&lt;fork&gt;&gt;\n    [*] --&gt; fork_state\n    fork_state --&gt; State2\n    fork_state --&gt; State3\n\n    state join_state &lt;&lt;join&gt;&gt;\n    State2 --&gt; join_state\n    State3 --&gt; join_state\n    join_state --&gt; State4\n    State4 --&gt; [*]</code></pre>"},{"location":"experimenting/depth/images/","title":"Experimental images","text":""},{"location":"experimenting/depth/servo_turnouts/","title":"Servo Turnouts","text":""},{"location":"experimenting/depth/servo_turnouts/#important-considerations-for-servo-operation","title":"Important considerations for servo operation","text":"<p>Servo turnouts are driven through a PCA9685 servo control board on an EX-IOExpander. Refer to ????????</p> <p>Test, test, test your servo parameters prior to connecting to an actual turnout/point. If you have defined angles that exceed the physical limits of your turnout, you will likely damage it and/or the servo mechanism.</p> <p>Treat each servo and turnout as an individual as not all servos (or turnouts/points for that matter) are created equal. An angle that works with one servo and associated turnout will not necessarily provide the exact same result with another. Differences in servo brands, mounting methods, and even normal manufacturing tolerances will need to be factored in to the servo angles in use.</p> <p>The EX-Toolbox Android application provides a servo movement testing tool to help you discover the necessary values for the angles below.</p> <p>Use flexible wire to connect your servo arm to the turnout/point. Using a flexible connection between the turnout and the servo mechanism means if anything does go wrong such as the turnout getting jammed or an incorrect servo angle being sent, it reduces the chance of damaging the turnout or servo.</p>"},{"location":"experimenting/depth/servo_turnouts/#defining-servo-based-turnout-objects","title":"Defining servo based turnout objects","text":"<p>Define servo based turnouts using EXRAIL.</p> <pre><code>SERVO_TURNOUT(id, vpin, active_angle, inactive_angle, profile, \"description\")\n</code></pre> <p>id = Unique turnout ID within the CommandStation. All other turnout commands will refer to this turnout by this id.</p> <p>pin = The ID of the pin the servo is connected to, which would typically be the VPin ID of the PCA9685 controller board.</p> <p>active_angle = The angle to which the servo will move when the turnout is thrown (This is a value passed to the servo drtiver, it is not in degrees).</p> <p>inactive_angle = The angle to which the servo will move when the turnout is closed.</p> <p>profile = The speed at which a turnout will move: Instant, Fast, Medium, Slow.</p> <p>description = A human-friendly description of the turnout that will appear in WiThrottle apps and Engine Driver. Note that this must be enclosed in quotes \u201c\u201d. In some cases the HIDDEN keyword can be used here to prevent the turnout being visible to the throttles.</p> <p>An example definition for a servo connected to the second control pins of the first PCA9685 connected to the CommandStation, using the slow profile for prototypical operation:</p> <pre><code>SERVO_TURNOUT(200, 101, 450, 110, Slow, \"Coal yard exit\")\n</code></pre>"},{"location":"exrail/Emergency%20Stop%20button/","title":"Emergency stop button","text":"<p>ONBUTTON(123) will start a sequence at this point when a button on vpin 123 is pressed. The ESTOPALL command will stop all locos and inform all throttles. The DONE command completes/terminates the process started by ONBUTTON.</p> <pre><code>ONBUTTON(123) ESTOPALL DONE\n</code></pre>"},{"location":"exrail/Startup%20Power%20On/","title":"Startup power","text":"<p>By default the Command station will start with the track power OFF.</p> <p>This can be inconvenient if you are using the free version of the WiThrottle app from the Apple store which does not have a power button.</p> <p>You can configure EXRAIL to power on at startup by using</p> <pre><code>AUTOSTART POWERON DONE\n</code></pre> <p>Alternatively, you can power tracks individually</p> <pre><code>AUTOSTART\n  SET_POWER(A,ON)\n  SET_POWER(D,ON)\n  DONE\n</code></pre>"},{"location":"exrail/roster-similar-locos/","title":"Roster for Similar Sound Locos","text":"<p>The ROSTER command in EXRAIL can be tedious if you have several sound locos with the same function settings. Using a preprocessor definition saves typing.</p> <pre><code>ROSTER(1201,\"Red class 99\",\"light/*horn/flash/bang/wallop/squeal/honk\") \nROSTER(1202,\"Green class 99\",\"light/*horn/flash/bang/wallop/squeal/honk\") \n</code></pre> <p>Can be simplified by pre-defining the functions:</p> <pre><code>#define CLASS99F \"light/*horn/flash/bang/wallop/squeal/honk\" \nROSTER(1201,\"Red class 99\",CLASS99F) \nROSTER(1202,\"Green class 99\",CLASS99F) \n</code></pre> <p>This technique is particularly useful for rostering DC tracks where the function keys are related to PWM frequency:</p> <pre><code>#define DCFuncs\"/////////////////////////////FQ490 Hz/FQ3400 Hz/FQ62500 Hz\"\nROSTER(1225,\"DC TRACK B 1225\",DCFuncs)\nROSTER(1226,\"DC TRACK C 1226\",DCFuncs)\n</code></pre> <p>It is also possible to utilise the compiler rule that \"Hello\" \"Sailor\" is treated as \"HelloSailor\". This means that common functions can be used with loco specific additions.</p> <pre><code>#define CommonFuncs \"light/*horn\" \nROSTER(1201,\"Noisy class 99\",CommonFuncs \"/flash/bang/wallop/squeal/honk\") \nROSTER(1202,\"Quieter class 99\",CommonFuncs) \n</code></pre>"},{"location":"exrail/Editing%20Tricks/Naming%20a%20sequence/","title":"Naming sequences for easy commands","text":"<p>The DCC-EX command</p> <pre><code>&lt;/START id&gt;\n</code></pre> <p>can be used to start a sequence when the sequence id is known.</p> <p>However its is sometimes more convenient to code a sequence so that it can be started by name.</p> <p>This is made possible by using upper case quoted sequence names with the _hk suffix.</p> <pre><code>SEQUENCE(\"BEER\"_hk)  \n  PRINT(\"BEER sequence started\")\n  ... and so on\n</code></pre> <p>The name must be specified in upper case but it can be started by the command in any mixed case.</p> <pre><code> &lt;/start beer&gt;\n</code></pre>"},{"location":"exrail/Editing%20Tricks/multi-files/","title":"Multiple Files in EXRAIL","text":"<p>EXRAIL commands are read by the compiler only from the file myAutomation.h, the absence of a file with this name means no EXRAIL code is loaded into the command station. However, it is simple to partition myAutomation.h into separate files for the convenience of editing. For example myTurnouts.h, myRoster.h and so on. By ensuring all the files start with \"my\" it avoids issues with name clashes or Git.</p> <p>To include your additional files, use the c++ preprocessor #include control in myAutomation.h to insert the file contents exactly as if you had typed them into myAutomation.h</p> <pre><code>// Include my roster file\n#include \"myRoster.h\"\n// Include my turnout definitions\n#include \"myTurnouts.h\"\n// Special animation\n#include \"myCowOnElectricFence.h\"\n</code></pre> <p>A note to hardened C++ programmers... do not be tempted to add include guards to your .h files.</p>"},{"location":"exrail/Turnouts/Animated%20Turnouts/","title":"Animated turnouts","text":"<p>Switching turnouts is easy, but sometimes you want to make it more realistic by introducing signals, delays and other automations.</p> <p>The combination of hidden and virtual turnouts makes this easy.</p> <p>Lets suppose you have a turnout id 100 and to make it look realistic you need to set some signal to stop, wait for the signalman to walk accross the lever frame, throw the turnout, wait again and set another signal to green. </p> <p>First we need to hide the real turnout from the throttles. This is done by changing the description to the keyword HIDDEN and gining it a different id so we can refer to it later.</p> <pre><code>  TURNOUTL(100,1,\"Coal yard exit\")  // for example\n</code></pre> <p>is changed to</p> <pre><code>  TURNOUTL(1001,1,HIDDEN) \n</code></pre> <p>Now we can create a virtual turnout that will be seen by the throttles and specify what we want to happen when it is thrown or closed.</p> <pre><code>   VIRTUAL_TURNOUT(100,\"Coal yard exit\")\n\n   ONCLOSE(100)\n     RED(501)  // set approach signal\n     RED(505)  // set approach signal\n     DELAY(4000) // wait for signalman to move\n     CLOSE(1001) // close the real turnout \n     DELAY(5000)\n     GREEN(501) // set approach signal\n     DONE\n\n   ONTHROW(100)\n     RED(501)  // set approach signal\n     RED(505)  // set approach signal\n     DELAY(4000) // wait for signalman to move\n     THROW(1001) // throw the real turnout \n     DELAY(5000)\n     GREEN(505) // set approach signal\n     DONE\n</code></pre>"},{"location":"exrail/Turnouts/Facing%20Turnouts/","title":"Facing turnouts","text":"<p>When you have turnouts that face each other, its awkward for the throttle user to have to manually switch  both to match each other. By treating the crossover as a single turnout, control is simplified and incorrect combinations are prevented.</p> <p>To do this, we need to hide one of the turnouts from the user, and make sure that throwing/closing the visible turnout automatically throws/closes the other turnout.</p> <p>All turnout definitions in EXRAIL allow for a text description to be shown to the user throttle. The HIDDEN keyword, used instead of a turnout description prevents it being visible to the throttle or JMRI/iTrain etc.</p> <pre><code>TURNOUTL(1,101,\"Cross inner to outer\")\nTURNOUTL(2,102,HIDDEN)\n\nONTHROW(1) THROW(2) DONE\nONCLOSE(1) CLOSE(2) DONE\n</code></pre>"},{"location":"exrail/Turnouts/Toggle%20Turnouts%20with%20button%20press/","title":"Toggle turnouts with button or sensor","text":"<p>A turnout of any type can be toggled by a button or sensor of any type. </p> <pre><code>ONBUTTON(123) TOGGLE_TURNOUT(6) DONE\n</code></pre>"},{"location":"products/ex-csb1/","title":"EX-CommandStation Booster 1 - EX-CSB1","text":"<p>This is the EX-CSB1 user manual page.</p> <p></p> <p></p>"},{"location":"reference/serial_command_basics/","title":"Serial Command Basics","text":"<ul> <li>Serial commands are accepted as input from the USB serial connection or a TCP/IP connection.</li> <li>Commands have a single case dependent character opcode and optionaly parameters.</li> <li>Keyword parameters are shown in upper case but may be entered in mixed case.</li> <li>Value parameters are decimal numeric (unless otherwise noted)</li> <li>Not all commands have a response, and broadcasts mean that not all responses come from the last commands that you have issued.</li> <li>Commands entered like <code>&lt;JA&gt;</code> are actually read as <code>&lt;J A&gt;</code>, so <code>&lt;Ja&gt;</code> is also acceptible. </li> <li>Commands that produce diagnostic information (which is intended for human reading rather than code) only write to the USB Serial output.</li> <li>Commands that cause state changes (such as loco speeds, turnout position) cause broadcasts to all serial connections and, where appropriate, WiThrottle protocol connections. </li> </ul>"},{"location":"reference/serial_commands/","title":"Serial commands","text":"<p><code>&lt;#&gt;</code></p> <p>Request number of simultaneously supported locos</p> <p><code>&lt;!&gt;</code></p> <p>Emergency stop all locos</p> <p><code>&lt;t loco&gt;</code></p> <p>Request loco status</p> <p><code>&lt;t loco tspeed direction&gt;</code></p> <p>Set throttle speed(0..127) and direction (0=reverse, 1=fwd) </p> <p><code>&lt;t ignore loco tspeed direction&gt;</code></p> <p>(Deprecated) Set throttle speed and direction</p> <p><code>&lt;f loco byte1&gt;</code></p> <p>(Deprecated use F) Set loco function group </p> <p><code>&lt;f loco group byte2&gt;</code></p> <p>(Deprecated use F) Set loco function group </p> <p><code>&lt;T&gt;</code></p> <p>List all turnouts</p> <p><code>&lt;T id&gt;</code></p> <p>Delete turnout</p> <p><code>&lt;T id X&gt;</code></p> <p>List turnout details</p> <p><code>&lt;T id T&gt;</code></p> <p>Throw Turnout</p> <p><code>&lt;T id C&gt;</code></p> <p>Close turnout#</p> <p><code>&lt;T id value&gt;</code></p> <p>Close (value=0) ot Throw turnout</p> <p><code>&lt;T id SERVO vpin closedValue thrownValue&gt;</code></p> <p>Create Servo turnout  </p> <p><code>&lt;T id VPIN vpin&gt;</code></p> <p>Create pin turnout</p> <p><code>&lt;T id DCC addr subadd&gt;</code></p> <p>Create DCC turnout </p> <p><code>&lt;T id DCC linearAddr&gt;</code></p> <p>Create DCC turnout</p> <p><code>&lt;T id addr subadd&gt;</code></p> <p>Create DCC turnout</p> <p><code>&lt;T id vpin closedValue thrownValue&gt;</code></p> <p>Create SERVO turnout</p> <p><code>&lt;S id vpin pullup&gt;</code></p> <p>Create Sensor</p> <p><code>&lt;S id&gt;</code></p> <p>Delete sensor</p> <p><code>&lt;S&gt;</code></p> <p>List sensors</p> <p><code>&lt;J M&gt;</code></p> <p>List stash values</p> <p><code>&lt;J M stash_id&gt;</code></p> <p>get stash value</p> <p><code>&lt;J M CLEAR ALL&gt;</code></p> <p>Clear all stash values</p> <p><code>&lt;J M CLEAR stash_id&gt;</code></p> <p>Clear given stash</p> <p><code>&lt;J M stashId locoId&gt;</code></p> <p>Set stash value</p> <p><code>&lt;J M CLEAR ANY locoId&gt;</code></p> <p>Clear all stash entries that contain locoId</p> <p><code>&lt;J C&gt;</code></p> <p>get fastclock time</p> <p><code>&lt;J C mmmm nn&gt;</code></p> <p>Set fastclock time</p> <p><code>&lt;J G&gt;</code></p> <p>FReport gauge limits </p> <p><code>&lt;J I&gt;</code></p> <p>Report currents </p> <p><code>&lt;J A&gt;</code></p> <p>List Routes</p> <p><code>&lt;J R&gt;</code></p> <p>List Roster</p> <p><code>&lt;J R id&gt;</code></p> <p>Get roster for loco</p> <p><code>&lt;J T&gt;</code></p> <p>Get turnout list </p> <p><code>&lt;J T id&gt;</code></p> <p>Get turnout state and description</p> <p><code>&lt;z vpin&gt;</code></p> <p>Set pin. HIGH iv vpin positive, LOW if vpin negative  </p> <p><code>&lt;z vpin analog profile duration&gt;</code></p> <p>Change analog value over duration (Fade or servo move)</p> <p><code>&lt;z vpin analog profile&gt;</code></p> <p>Write analog device using profile number (Fade or servo movement)</p> <p><code>&lt;z vpin analog&gt;</code></p> <p>Write analog device value</p> <p><code>&lt;I&gt;</code></p> <p>List all turntables</p> <p><code>&lt;I id&gt;</code></p> <p>Broadcast turntable type and current position    </p> <p><code>&lt;I id position&gt;</code></p> <p>Rotate a DCC turntable</p> <p><code>&lt;I id DCC home&gt;</code></p> <p>Create DCC turntable</p> <p><code>&lt;I id position activity&gt;</code></p> <p>Rotate an EXTT turntable</p> <p><code>&lt;I id EXTT vpin home&gt;</code></p> <p>Create an EXTT turntable</p> <p><code>&lt;I id ADD position value angle&gt;</code></p> <p>Add turntable position</p> <p><code>&lt;Q&gt;</code></p> <p>List all sensors </p> <p><code>&lt;s&gt;</code></p> <p>Command station status</p> <p><code>&lt;E&gt;</code></p> <p>STORE EPROM</p> <p><code>&lt;e&gt;</code></p> <p>CLEAR EPROM</p> <p><code>&lt;Z&gt;</code></p> <p>List Output definitions </p> <p><code>&lt;Z id pin iflag&gt;</code></p> <p>Create Output</p> <p><code>&lt;Z id active&gt;</code></p> <p>Set output </p> <p><code>&lt;Z id&gt;</code></p> <p>Delete output</p> <p><code>&lt;D ACK ON&gt;</code></p> <p>Enable PROG track diagnostics</p> <p><code>&lt;D ACK OFF&gt;</code></p> <p>Disable PROG track diagnostics</p> <p><code>&lt;D CABS&gt;</code></p> <p>Diagnostic display loco state table</p> <p><code>&lt;D RAM&gt;</code></p> <p>Diagnostic display free RAM</p> <p><code>&lt;D CMD ON&gt;</code></p> <p>Enable command input diagnostics</p> <p><code>&lt;D CMD OFF&gt;</code></p> <p>Disable command input diagnostics</p> <p><code>&lt;D RAILCOM ON&gt;</code></p> <p>Enable Railcom diagnostics</p> <p><code>&lt;D RAILCOM OFF&gt;</code></p> <p>DIsable Railcom diagnostics</p> <p><code>&lt;D WIFI ON&gt;</code></p> <p>Enable Wifi diagnostics</p> <p><code>&lt;D WIFI OFF&gt;</code></p> <p>Disable Wifi diagnostics</p> <p><code>&lt;D ETHERNET ON&gt;</code></p> <p>Enable Ethernet diagnostics</p> <p><code>&lt;D ETHERNET OFF&gt;</code></p> <p>Disabel Ethernet diagnostics </p> <p><code>&lt;D WIT ON&gt;</code></p> <p>Enable Withrottle diagnostics</p> <p><code>&lt;D WIT OFF&gt;</code></p> <p>Disable Withrottle diagnostics </p> <p><code>&lt;D LCN ON&gt;</code></p> <p>Enable LCN Diagnostics</p> <p><code>&lt;D LCN OFF&gt;</code></p> <p>Disabel LCN diagnostics</p> <p><code>&lt;D WEBSOCKET ON&gt;</code></p> <p>Enable Websocket diagnostics </p> <p><code>&lt;D WEBSOCKET OFF&gt;</code></p> <p>Disable wensocket diagnostics </p> <p><code>&lt;D EEPROM numentries&gt;</code></p> <p>Dump EEPROM contents</p> <p><code>&lt;D ANOUT vpin position&gt;</code></p> <p>see  <p><code>&lt;D ANOUT vpin position profile&gt;</code></p> <p>see  <p><code>&lt;D SERVO vpin position&gt;</code></p> <p>Test servo</p> <p><code>&lt;D SERVO vpin position profile&gt;</code></p> <p>Test servo</p> <p><code>&lt;D ANIN vpin&gt;</code></p> <p>Display analogue input value</p> <p><code>&lt;D HAL SHOW&gt;</code></p> <p>Show HAL devices table</p> <p><code>&lt;D HAL RESET&gt;</code></p> <p>Reset all HAL devices</p> <p><code>&lt;D TT vpin steps&gt;</code></p> <p>Test turntable</p> <p><code>&lt;D TT vpin steps activity&gt;</code></p> <p>Test turntable</p> <p><code>&lt;C PROGBOOST&gt;</code></p> <p>Configute PROG track boost</p> <p><code>&lt;C RESET&gt;</code></p> <p>Reset and restart command station</p> <p><code>&lt;C SPEED28&gt;</code></p> <p>Set all DCC speed commands as 28 step to old decoders</p> <p><code>&lt;C SPEED128&gt;</code></p> <p>Set all DCC speed commands to 128 step (default)</p> <p><code>&lt;C RAILCOM ON&gt;</code></p> <p>Enable Railcom cutout </p> <p><code>&lt;C RAILCOM OFF&gt;</code></p> <p>Disable Railcom cutout</p> <p><code>&lt;C RAILCOM DEBUG&gt;</code></p> <p>Enable Railcom cutout for easy scope reading test</p> <p><code>&lt;D ACK LIMIT value&gt;</code></p> <p>Set ACK detection limit mA</p> <p><code>&lt;D ACK MIN value MS&gt;</code></p> <p>Set ACK minimum duration mS</p> <p><code>&lt;D ACK MIN value&gt;</code></p> <p>Set ACK minimum duration uS</p> <p><code>&lt;D ACK MAX value MS&gt;</code></p> <p>Set ACK maximum duration mS</p> <p><code>&lt;D ACK MAX value&gt;</code></p> <p>Set ACK maximum duration uS</p> <p><code>&lt;D ACK RETRY value&gt;</code></p> <p>Set ACK retry count</p> <p><code>&lt;C WIFI \"ssid\" \"password\"&gt;</code></p> <p>reconfigure stored wifi credentials </p> <p><code>&lt;o vpin&gt;</code></p> <p>Set neopixel on(vpin&gt;0) or off(vpin&lt;0)</p> <p><code>&lt;o vpin count&gt;</code></p> <p>Set multiple neopixels on(vpin&gt;0) or off(vpin&lt;0)</p> <p><code>&lt;o vpin r g b&gt;</code></p> <p>Set neopixel colour</p> <p><code>&lt;o vpin r g b count&gt;</code></p> <p>Set multiple neopixels colour </p> <p><code>&lt;1&gt;</code></p> <p>Power ON all tracks</p> <p><code>&lt;1 MAIN&gt;</code></p> <p>Power on MAIN track</p> <p><code>&lt;1 PROG&gt;</code></p> <p>Power on PROG track</p> <p><code>&lt;1 JOIN&gt;</code></p> <p>JOIN prog track to MAIN and power</p> <p><code>&lt;1 track&gt;</code></p> <p>Power on given track</p> <p><code>&lt;0&gt;</code></p> <p>Power off all tracks</p> <p><code>&lt;0 MAIN&gt;</code></p> <p>Power off MAIN track</p> <p><code>&lt;0 PROG&gt;</code></p> <p>Power off PROG track</p> <p><code>&lt;0 track&gt;</code></p> <p>Power off given track</p> <p><code>&lt;c&gt;</code></p> <p>Report main track currect (Deprecated)</p> <p><code>&lt;a address subaddress activate&gt;</code></p> <p>Send DCC accessory command</p> <p><code>&lt;a address subaddress activate onoff&gt;</code></p> <p>Send DCC accessory command with onoff control (TODO.. numbers) </p> <p><code>&lt;a linearaddress activate&gt;</code></p> <p>send dcc accessory command      </p> <p><code>&lt;A address value&gt;</code></p> <p>Send DCC extended accessory (Aspect) command</p> <p><code>&lt;w loco cv value&gt;</code></p> <p>POM write cv on main track</p> <p><code>&lt;r loco cv&gt;</code></p> <p>POM read cv on main track</p> <p><code>&lt;b loco cv bit bitvalue&gt;</code></p> <p>POM write cv bit on main track</p> <p><code>&lt;m LINEAR&gt;</code></p> <p>Set Momentum algorithm to linear acceleration</p> <p><code>&lt;m POWER&gt;</code></p> <p>Set momentum algortithm to very based on difference between current speed and throttle seting</p> <p><code>&lt;m loco momentum&gt;</code></p> <p>set momentum for loco (accel and braking)</p> <p><code>&lt;m loco accelerating braking&gt;</code></p> <p>set momentum for loco</p> <p><code>&lt;W cv value ignore1 ignore2&gt;</code></p> <p>(Deprecated) Write cv value on PROG track</p> <p><code>&lt;W loco&gt;</code></p> <p>Write loco address on PROG track</p> <p><code>&lt;W CONSIST loco REVERSE&gt;</code></p> <p>Write consist address and reverse flag on PROG track </p> <p><code>&lt;W CONSIST loco&gt;</code></p> <p>write consist address on PROG track       </p> <p><code>&lt;W cv value&gt;</code></p> <p>Write cv value on PROG track</p> <p><code>&lt;W cv bitvalue bit&gt;</code></p> <p>Write cv bit on prog track</p> <p><code>&lt;V cv value&gt;</code></p> <p>Fast read cv with expected value</p> <p><code>&lt;V cv bit bitvalue&gt;</code></p> <p>Fast read bit with expected value</p> <p><code>&lt;B cv bit bitvalue&gt;</code></p> <p>Write cv bit</p> <p><code>&lt;R cv ignore1 ignore2&gt;</code></p> <p>(Deprecated) read cv value on PROG track</p> <p><code>&lt;R cv&gt;</code></p> <p>Read cv</p> <p><code>&lt;R&gt;</code></p> <p>Read driveable loco id (may be long, short or consist)</p> <p><code>&lt;-&gt;</code></p> <p>Clear loco state and reminder table</p> <p><code>&lt;- loco&gt;</code></p> <p>remove loco state amnd reminders</p> <p><code>&lt;F loco DCCFREQ freqvalue&gt;</code></p> <p>Set DC frequencey for loco   </p> <p><code>&lt;F loco function onoff&gt;</code></p> <p>Set loco function ON/OFF</p> <p><code>&lt;M ignore d0 d1 d2 d3 d4 d5&gt;</code></p> <p>Send up to 5 byte DCC packet on MAIN track (all d values in hex)</p> <p><code>&lt;P ignore d0 d1 d2 d3 d4 d5&gt;</code></p> <p>Send up to 5 byte DCC packet on PROG track (all d values in hex)</p> <p><code>&lt;J O&gt;</code></p> <p>List turntable IDs</p> <p><code>&lt;J O id&gt;</code></p> <p>List turntable state</p> <p><code>&lt;J P id&gt;</code></p> <p>list turntable positions</p> <p><code>&lt;=&gt;</code></p> <p>list track manager states</p> <p><code>&lt;= track MAIN&gt;</code></p> <p>Set track to MAIN</p> <p><code>&lt;= track MAIN_INV&gt;</code></p> <p>Set track to MAIN inverted polatity</p> <p><code>&lt;= track MAIN_AUTO&gt;</code></p> <p>Set track to MAIN with auto reversing</p> <p><code>&lt;= track PROG&gt;</code></p> <p>Set track to PROG</p> <p><code>&lt;= track OFF&gt;</code></p> <p>Set track power OFF</p> <p><code>&lt;= track NONE&gt;</code></p> <p>Set track no output</p> <p><code>&lt;= track EXT&gt;</code></p> <p>Set track to use external sync</p> <p><code>&lt;= track AUTO&gt;</code></p> <p>Update track to auto reverse</p> <p><code>&lt;= track INV&gt;</code></p> <p>Update track to inverse polarity</p> <p><code>&lt;= track DC loco&gt;</code></p> <p>Set track to DC</p> <p><code>&lt;= track DC_INV loco&gt;</code></p> <p>Set track to DC with inverted polarity</p> <p><code>&lt;= track DCX loco&gt;</code></p> <p>Set track to DC with inverted polarity</p>"}]}